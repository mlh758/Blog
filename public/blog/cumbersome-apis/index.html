<!DOCTYPE html>
<html lang="en">
    <head>
        
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        

        <title></title>

        
            <link rel="stylesheet" href="https://webshittery.com/theme.css">
        
        
    </head>
    <body>
        <div class="content">
        
        
            <header>
                <div class="header-left">
                    <a href="https:&#x2F;&#x2F;webshittery.com" class="logo"></a>
                </div>
                <div class="header-right">
                    <nav itemscope itemtype="http://schema.org/SiteNavigationElement">
                      <ul>
                        
                        
                            
                            <li class="nav">
                                <a itemprop="url" href="https://webshittery.com/blog/">
                                    <span itemprop="name">Blog</span>
                                </a>
                            </li>
                        
                        
                        <li class="nav">
                            <a itemprop="url" href="https://github.com/mlh758">
                                <img class="icon" src="https:&#x2F;&#x2F;webshittery.com/icons/github.svg" alt="Github">
                            </a>
                        </li>
                        
                        
                      </ul>
                    </nav>
                </div>
            </header>
        
        
        <main>
            
<article itemscope itemtype="http://schema.org/BlogPosting">
    <div itemprop="headline">
        <h1>Unintended Consequences of Cumbersome APIs</h1>
        <div class="border"></div>
        <time datetime="2024-08-31" class="date" itemprop="datePublished">
            31 Aug 2024
        </time>
    </div>
    <div itemprop="articleBody">
        <p>I recently found myself working an issue on the front end of one of our applications. The functionality I was looking into involved
a form building screen where you define questions for a user to complete. You can drag and drop questions to change the order. If you
click on one of the questions it expands so you can configure details about the question such as the type of responses accepted. The problem
I was investigating was that sometimes if you dragged and released an item it would get stuck outside of the list and become
unresponsive from that point onward.</p>
<p>When I started testing the application I made a form and started dragging items around. I noticed that the page slowed down quite a bit
as I moved items and if I jiggled an item quickly it tended to get stuck outside of the form. I also noticed that if I opened
one of the questions and tried to modify it, every key stroke was delayed. Using the React profiling tools it was taking about 100ms
to render each key stroke on my laptop.</p>
<p>The first thing I wanted to fix was the lag/jitter trying to drag items. Every time one of the dragged elements crossed another
triggering an order change there was a noticeable delay. Everything involved in the form builder was re-rendering. At
this point I usually take a look at the library APIs and see if I can minimize what is actually being updated to limit the fallout.
The form builder was created using <code>react-hook-form</code>. Since the form is a dynamic list of questions it was using the <code>useFieldArray</code>
hook specifically. We were updating the fields with <code>replace</code> which as you might assume replaces the entire contents of the array.
There is also a <code>move</code> function returned by <code>useFieldArray</code> which seemed like a natural fit given that we were moving one item
elsewhere in the array. This should cause fewer updates in the tree and fewer renders.</p>
<h2 id="never-that-easy">Never that easy</h2>
<p>My good luck ran out there. To do the animations we were using the Framer library's <code>Reorder.Group</code>. To notify your application
of a change in order it provides a callback <code>onReorder</code> which just hands you back the new list of items. This is why we were using
<code>replace</code> instead of the more limited <code>move</code>. It also lead to a lot of complexity in the surrounding component since we needed to react
to specific changes in ordering which lead to a fair amount of complex code trying to keep the old state around and compare it to any
new state coming out. This also meant some extra memoization, copying props into state, and <code>useEffect</code> to try and reconcile it all together.
The simple API just wasn't giving us the information we needed and it put quite a bit of additional burden on the consuming component
instead.</p>
<p>I was convinced there had to be an easier way to get this information but Framer doesn't provide any other callbacks that I could find and I really wanted to get this complexity out of the component while being able to use the narrower <code>move</code> function from <code>useFieldArray</code>.</p>
<h2 id="i-wonder-if-copilot-will-make-this-easier">I wonder if Copilot will make this easier</h2>
<p>My first thought was to do something simple like iterate over the new array comparing the order to the old one. When I find the changed element use <code>findIndex</code> on the old array and done. I knew right away this was too simplistic since whichever direction I iterated from reordering up or down the array would make one of those look like too many things had changed. This seemed like a common enough problem that I could probably get an LLM to make this function for me. This was only the first step in trying to optimize a pretty deep component tree and I didn't want to spend a lot of time on it.</p>
<h3 id="hey-that-s-just-my-bad-idea-again">Hey that's just my bad idea again</h3>
<p>I used this prompt:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Given two arrays of IDs where a single element was moved to a new location in the array,</span><span>
</span><span>determine which element was moved and to which location.</span><span>
</span><span>
</span><span>Also tried: Given two arrays A and B where A is the original state and B is the array</span><span>
</span><span>after moving one item to another location in the array,</span><span>
</span><span>provide a function for determining which element was moved and to where.</span><span>
</span></code></pre>
<p>I received this code in response:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">findMovedElement</span><span>(</span><span style="color:#bf616a;">originalArray</span><span>, </span><span style="color:#bf616a;">newArray</span><span>) {</span><span>
</span><span>  </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">movedElement </span><span>= </span><span style="color:#d08770;">null</span><span>;</span><span>
</span><span>  </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">originalIndex </span><span>= -</span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>  </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">newIndex </span><span>= -</span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Create a map to store the indices of elements in the original array</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">originalIndexMap </span><span>= new Map();</span><span>
</span><span>  </span><span style="color:#bf616a;">originalArray</span><span>.</span><span style="color:#96b5b4;">forEach</span><span>((</span><span style="color:#bf616a;">element</span><span>, </span><span style="color:#bf616a;">index</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>{</span><span>
</span><span>    </span><span style="color:#bf616a;">originalIndexMap</span><span>.</span><span style="color:#96b5b4;">set</span><span>(</span><span style="color:#bf616a;">element</span><span>, </span><span style="color:#bf616a;">index</span><span>);</span><span>
</span><span>  });</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Iterate through the new array to find the moved element</span><span>
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt; </span><span style="color:#bf616a;">newArray</span><span>.length; </span><span style="color:#bf616a;">i</span><span>++) {</span><span>
</span><span>    </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">element </span><span>= </span><span style="color:#bf616a;">newArray</span><span>[</span><span style="color:#bf616a;">i</span><span>];</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">originalIndexMap</span><span>.</span><span style="color:#96b5b4;">has</span><span>(</span><span style="color:#bf616a;">element</span><span>)) {</span><span>
</span><span>      </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">originalIdx </span><span>= </span><span style="color:#bf616a;">originalIndexMap</span><span>.</span><span style="color:#96b5b4;">get</span><span>(</span><span style="color:#bf616a;">element</span><span>);</span><span>
</span><span>      </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">originalIdx </span><span>!== </span><span style="color:#bf616a;">i</span><span>) {</span><span>
</span><span>        </span><span style="color:#bf616a;">movedElement </span><span>= </span><span style="color:#bf616a;">element</span><span>;</span><span>
</span><span>        </span><span style="color:#bf616a;">originalIndex </span><span>= </span><span style="color:#bf616a;">originalIdx</span><span>;</span><span>
</span><span>        </span><span style="color:#bf616a;">newIndex </span><span>= </span><span style="color:#bf616a;">i</span><span>;</span><span>
</span><span>        </span><span style="color:#b48ead;">break</span><span>;</span><span>
</span><span>      }</span><span>
</span><span>    }</span><span>
</span><span>  }</span><span>
</span><span>
</span><span>  </span><span style="color:#b48ead;">return </span><span>{ </span><span style="color:#bf616a;">movedElement</span><span>, </span><span style="color:#bf616a;">originalIndex</span><span>, </span><span style="color:#bf616a;">newIndex </span><span>};</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This is basically what I had envisioned doing initially and knew couldn't be correct. Here's an initial test:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">let </span><span style="color:#bf616a;">a </span><span>= [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>]</span><span>
</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">b </span><span>= [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>]</span><span>
</span><span style="color:#8fa1b3;">findMovedElement</span><span>(</span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>) </span><span style="color:#65737e;">// {movedElement: 3, originalIndex: 2, newIndex: 1}</span><span>
</span></code></pre>
<p>So far so good I suppose. But what about the other direction and not a trivial swap?</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#bf616a;">b </span><span>= [</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">1</span><span>]</span><span>
</span><span style="color:#8fa1b3;">findMovedElement</span><span>(</span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>) </span><span style="color:#65737e;">// {movedElement: 2, originalIndex: 1, newIndex: 0}</span><span>
</span></code></pre>
<p>Well that's not right. I dragged  <code>1</code> down to the end. <code>2</code> just seems like it moved because
the algorithm is only looking at the first mismatch and stopping. Then it hit me, drag and drop
is just a single deletion followed by a single insertion.</p>
<h3 id="this-is-a-solved-problem">This is a solved problem</h3>
<p>I had recently read through the excellent <em>Algorithm Design Manual</em> by Steven Skiena and it was still on my desk. Why no, potential coworkers reading this, I'm not doing any interview prep. I really do just enjoy reading books like that.</p>
<p><strong>Move along.</strong></p>
<p>Section 10.2.2 is <em>Edit Distance by Dynamic Programming</em>. Given a sequence of values, what is
the minimum number of insertions, deletions, and substitutions needed to turn one sequence into the other. With dynamic programming you end up with a table that records the steps taken to arrive at the answer and so you can traverse that table to arrive at the information I was looking for. The next section of the book does exactly this.</p>
<p>Unfortunately I'm also somewhat lazy and I didn't feel like piecing together the code from several examples and translating it from C to JavaScript. I'm also really not supposed to be spending much time on the issue. Now that I have a better idea of what I'm asking for, let's try the LLM again.</p>
<h3 id="ai-tries-edit-distance">AI tries edit distance</h3>
<p>This was my next prompt:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Given two arrays A and B where A is the original state and B</span><span>
</span><span>is the array after moving one item to another location in the</span><span>
</span><span>array, provide a function for determining which element was</span><span>
</span><span>moved using the Levenshtein edit distance algorithm</span><span>
</span></code></pre>
<p>I was given this code in return:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">findMovedElementUsingEditDistance</span><span>(</span><span style="color:#bf616a;">A</span><span>, </span><span style="color:#bf616a;">B</span><span>) {</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">m </span><span>= </span><span style="color:#bf616a;">A</span><span>.length;</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">n </span><span>= </span><span style="color:#bf616a;">B</span><span>.length;</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Initialize the dp table</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">dp </span><span>= </span><span style="color:#ebcb8b;">Array</span><span>.</span><span style="color:#8fa1b3;">from</span><span>({ length: </span><span style="color:#bf616a;">m </span><span>+ </span><span style="color:#d08770;">1 </span><span>}, () </span><span style="color:#b48ead;">=&gt; </span><span style="color:#ebcb8b;">Array</span><span>(</span><span style="color:#bf616a;">n </span><span>+ </span><span style="color:#d08770;">1</span><span>).</span><span style="color:#8fa1b3;">fill</span><span>(</span><span style="color:#d08770;">0</span><span>));</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Fill in the base cases</span><span>
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">m</span><span>; </span><span style="color:#bf616a;">i</span><span>++) </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#d08770;">0</span><span>] = </span><span style="color:#bf616a;">i</span><span>;</span><span>
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">j </span><span>= </span><span style="color:#d08770;">0</span><span>; </span><span style="color:#bf616a;">j </span><span>&lt;= </span><span style="color:#bf616a;">n</span><span>; </span><span style="color:#bf616a;">j</span><span>++) </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#d08770;">0</span><span>][</span><span style="color:#bf616a;">j</span><span>] = </span><span style="color:#bf616a;">j</span><span>;</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Fill in the dp table</span><span>
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">m</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">j </span><span>= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">j </span><span>&lt;= </span><span style="color:#bf616a;">n</span><span>; </span><span style="color:#bf616a;">j</span><span>++) {</span><span>
</span><span>      </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">A</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>] === </span><span style="color:#bf616a;">B</span><span>[</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>]) {</span><span>
</span><span>        </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j</span><span>] = </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>][</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>];</span><span>
</span><span>      } </span><span style="color:#b48ead;">else </span><span>{</span><span>
</span><span>        </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j</span><span>] = Math.</span><span style="color:#96b5b4;">min</span><span>(</span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>][</span><span style="color:#bf616a;">j</span><span>], </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>]) + </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>      }</span><span>
</span><span>    }</span><span>
</span><span>  }</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Trace back to find the moved element</span><span>
</span><span>  </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#bf616a;">m</span><span>, </span><span style="color:#bf616a;">j </span><span>= </span><span style="color:#bf616a;">n</span><span>;</span><span>
</span><span>  </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">movedElement </span><span>= </span><span style="color:#d08770;">null</span><span>;</span><span>
</span><span>  </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">originalIndex </span><span>= -</span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>  </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">newIndex </span><span>= -</span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>
</span><span>  </span><span style="color:#b48ead;">while </span><span>(</span><span style="color:#bf616a;">i </span><span>&gt; </span><span style="color:#d08770;">0 </span><span>&amp;&amp; </span><span style="color:#bf616a;">j </span><span>&gt; </span><span style="color:#d08770;">0</span><span>) {</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">A</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>] === </span><span style="color:#bf616a;">B</span><span>[</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>]) {</span><span>
</span><span>      </span><span style="color:#bf616a;">i</span><span>--;</span><span>
</span><span>      </span><span style="color:#bf616a;">j</span><span>--;</span><span>
</span><span>    } </span><span style="color:#b48ead;">else if </span><span>(</span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j</span><span>] === </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>][</span><span style="color:#bf616a;">j</span><span>] + </span><span style="color:#d08770;">1</span><span>) {</span><span>
</span><span>      </span><span style="color:#65737e;">// Deletion in A</span><span>
</span><span>      </span><span style="color:#bf616a;">i</span><span>--;</span><span>
</span><span>    } </span><span style="color:#b48ead;">else if </span><span>(</span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j</span><span>] === </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>] + </span><span style="color:#d08770;">1</span><span>) {</span><span>
</span><span>      </span><span style="color:#65737e;">// Insertion in B</span><span>
</span><span>      </span><span style="color:#bf616a;">j</span><span>--;</span><span>
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{</span><span>
</span><span>      </span><span style="color:#65737e;">// Move operation</span><span>
</span><span>      </span><span style="color:#bf616a;">movedElement </span><span>= </span><span style="color:#bf616a;">A</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>];</span><span>
</span><span>      </span><span style="color:#bf616a;">originalIndex </span><span>= </span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>      </span><span style="color:#bf616a;">newIndex </span><span>= </span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>      </span><span style="color:#b48ead;">break</span><span>;</span><span>
</span><span>    }</span><span>
</span><span>  }</span><span>
</span><span>
</span><span>  </span><span style="color:#b48ead;">return </span><span>{ </span><span style="color:#bf616a;">movedElement</span><span>, </span><span style="color:#bf616a;">originalIndex</span><span>, </span><span style="color:#bf616a;">newIndex </span><span>};</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Testing with our same <code>b</code> array as before:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">let </span><span style="color:#bf616a;">b </span><span>= [</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">2</span><span>]</span><span>
</span><span style="color:#8fa1b3;">findMovedElementUsingEditDistance</span><span>(</span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>) </span><span style="color:#65737e;">// {movedElement: null, originalIndex: -1, newIndex: -1}</span><span>
</span></code></pre>
<p>Well that's not right. Let's prompt a correction:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>When I provide arrays [1, 2, 3, 4, 5] and [1, 3, 4, 5, 2] The answer should be { movedElement: 2, originalIndex: 1, newIndex: 4} but with that function the movedElement is null which is incorrect</span><span>
</span></code></pre>
<p>When I did that it just stuck a variation of the first, already incorrect code at the end of the edit distance function and called into that if the trace didn't return an answer. At least I didn't get <code>null</code> anymore I guess?</p>
<p>In retrospect I think it was the trace back code that was incorrect here. It also didn't use Levenshtein distance. I've run into this kind of issue before tinkering with LLMs to create code I was curious about. For example I tried to have one generate code implementing a <a href="https://en.wikipedia.org/wiki/Generic_cell_rate_algorithm">generic cell rate algorithm</a>. I was going to be storing rate limiting information in Redis and updating it with a Lua script. GCRA requires less state than some other token bucket style algorithms which would mean fewer moving parts within Redis to keep track of. No matter how I asked, I would always get an implementation of token bucket, and usually incorrect ones. There's just far more example code of that floating around.</p>
<p>You can see that in the trace code insertions and deletions are ignored completely. If instead I modify the trace code to <em>only</em> look at those two operations, and catch the boundary case where items are moved to or from the edges of the list (such as last element moved to first) then I seem to get correct answers. I didn't look too carefully at this before since I wasn't getting the answers I wanted and didn't feel like debugging AI code if I wasn't going to keep it.</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#bf616a;">m</span><span>, </span><span style="color:#bf616a;">j </span><span>= </span><span style="color:#bf616a;">n</span><span>;</span><span>
</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">movedElement </span><span>= </span><span style="color:#d08770;">null</span><span>;</span><span>
</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">originalIndex </span><span>= -</span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">newIndex </span><span>= -</span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>
</span><span style="color:#b48ead;">while </span><span>(</span><span style="color:#bf616a;">i </span><span>&gt; </span><span style="color:#d08770;">0 </span><span>&amp;&amp; </span><span style="color:#bf616a;">j </span><span>&gt; </span><span style="color:#d08770;">0</span><span>) {</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">A</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>] === </span><span style="color:#bf616a;">B</span><span>[</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>]) {</span><span>
</span><span>    </span><span style="color:#bf616a;">i</span><span>--;</span><span>
</span><span>    </span><span style="color:#bf616a;">j</span><span>--;</span><span>
</span><span>  } </span><span style="color:#b48ead;">else if </span><span>(</span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j</span><span>] === </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>][</span><span style="color:#bf616a;">j</span><span>] + </span><span style="color:#d08770;">1</span><span>) {</span><span>
</span><span>    </span><span style="color:#65737e;">// Deletion in A</span><span>
</span><span>    </span><span style="color:#bf616a;">movedElement </span><span>= </span><span style="color:#bf616a;">A</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>];</span><span>
</span><span>    </span><span style="color:#bf616a;">originalIndex </span><span>= </span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>    </span><span style="color:#bf616a;">i</span><span>--;</span><span>
</span><span>  } </span><span style="color:#b48ead;">else if </span><span>(</span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j</span><span>] === </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>] + </span><span style="color:#d08770;">1</span><span>) {</span><span>
</span><span>    </span><span style="color:#65737e;">// Insertion in B</span><span>
</span><span>    </span><span style="color:#bf616a;">movedElement </span><span>= </span><span style="color:#bf616a;">B</span><span>[</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>];</span><span>
</span><span>    </span><span style="color:#bf616a;">newIndex </span><span>= </span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>    </span><span style="color:#bf616a;">j</span><span>--;</span><span>
</span><span>  }</span><span>
</span><span>}</span><span>
</span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">newIndex </span><span>=== -</span><span style="color:#d08770;">1 </span><span>&amp;&amp; </span><span style="color:#bf616a;">j </span><span>&gt; </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#bf616a;">newIndex </span><span>= </span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">originalIndex </span><span>=== -</span><span style="color:#d08770;">1 </span><span>&amp;&amp; </span><span style="color:#bf616a;">i </span><span>&gt; </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#bf616a;">originalIndex </span><span>= </span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>;</span><span>
</span></code></pre>
<h3 id="i-was-making-this-too-complicated">I was making this too complicated</h3>
<p>After moving on to work I as actually supposed to be doing for a while I realized I was asking Copilot to generate code for a somewhat less common and more general algorithm. It didn't do that of course, as we saw above, but it seemed to be struggling with my request. Longest Common Subsequence is <em>also</em> an edit distance function, and it's a simpler one that only supports insertion and deletion. There's probably more sample code for this floating around the internet.</p>
<p>Here is the prompt I used:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Given two arrays: const A = [1, 2, 3, 4, 5]; const B = [1, 3, 4, 5, 2];</span><span>
</span><span>Use longest common subsequence to show the single deletion and insertion required to turn A into B</span><span>
</span><span>I also need to know the indexes at which the insertions and deletions happen</span><span>
</span></code></pre>
<p>I received this code in response:</p>
<pre data-lang="js" style="background-color:#2b303b;color:#c0c5ce;" class="language-js "><code class="language-js" data-lang="js"><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">longestCommonSubsequence</span><span>(</span><span style="color:#bf616a;">A</span><span>, </span><span style="color:#bf616a;">B</span><span>) {</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">m </span><span>= </span><span style="color:#bf616a;">A</span><span>.length;</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">n </span><span>= </span><span style="color:#bf616a;">B</span><span>.length;</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Initialize the dp table</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">dp </span><span>= </span><span style="color:#ebcb8b;">Array</span><span>.</span><span style="color:#8fa1b3;">from</span><span>({ length: </span><span style="color:#bf616a;">m </span><span>+ </span><span style="color:#d08770;">1 </span><span>}, () </span><span style="color:#b48ead;">=&gt; </span><span style="color:#ebcb8b;">Array</span><span>(</span><span style="color:#bf616a;">n </span><span>+ </span><span style="color:#d08770;">1</span><span>).</span><span style="color:#8fa1b3;">fill</span><span>(</span><span style="color:#d08770;">0</span><span>));</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Fill in the dp table</span><span>
</span><span>  </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">i </span><span>&lt;= </span><span style="color:#bf616a;">m</span><span>; </span><span style="color:#bf616a;">i</span><span>++) {</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">j </span><span>= </span><span style="color:#d08770;">1</span><span>; </span><span style="color:#bf616a;">j </span><span>&lt;= </span><span style="color:#bf616a;">n</span><span>; </span><span style="color:#bf616a;">j</span><span>++) {</span><span>
</span><span>      </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">A</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>] === </span><span style="color:#bf616a;">B</span><span>[</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>]) {</span><span>
</span><span>        </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j</span><span>] = </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>][</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>] + </span><span style="color:#d08770;">1</span><span>;</span><span>
</span><span>      } </span><span style="color:#b48ead;">else </span><span>{</span><span>
</span><span>        </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j</span><span>] = Math.</span><span style="color:#96b5b4;">max</span><span>(</span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>][</span><span style="color:#bf616a;">j</span><span>], </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>]);</span><span>
</span><span>      }</span><span>
</span><span>    }</span><span>
</span><span>  }</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Trace back to find the LCS</span><span>
</span><span>  </span><span style="color:#b48ead;">let </span><span style="color:#bf616a;">i </span><span>= </span><span style="color:#bf616a;">m</span><span>, </span><span style="color:#bf616a;">j </span><span>= </span><span style="color:#bf616a;">n</span><span>;</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">lcs </span><span>= [];</span><span>
</span><span>
</span><span>  </span><span style="color:#b48ead;">while </span><span>(</span><span style="color:#bf616a;">i </span><span>&gt; </span><span style="color:#d08770;">0 </span><span>&amp;&amp; </span><span style="color:#bf616a;">j </span><span>&gt; </span><span style="color:#d08770;">0</span><span>) {</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">A</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>] === </span><span style="color:#bf616a;">B</span><span>[</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>]) {</span><span>
</span><span>      </span><span style="color:#bf616a;">lcs</span><span>.</span><span style="color:#96b5b4;">unshift</span><span>({ value: </span><span style="color:#bf616a;">A</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>], indexA: </span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>, indexB: </span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1 </span><span>});</span><span>
</span><span>      </span><span style="color:#bf616a;">i</span><span>--;</span><span>
</span><span>      </span><span style="color:#bf616a;">j</span><span>--;</span><span>
</span><span>    } </span><span style="color:#b48ead;">else if </span><span>(</span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i </span><span>- </span><span style="color:#d08770;">1</span><span>][</span><span style="color:#bf616a;">j</span><span>] &gt;= </span><span style="color:#bf616a;">dp</span><span>[</span><span style="color:#bf616a;">i</span><span>][</span><span style="color:#bf616a;">j </span><span>- </span><span style="color:#d08770;">1</span><span>]) {</span><span>
</span><span>      </span><span style="color:#bf616a;">i</span><span>--;</span><span>
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{</span><span>
</span><span>      </span><span style="color:#bf616a;">j</span><span>--;</span><span>
</span><span>    }</span><span>
</span><span>  }</span><span>
</span><span>
</span><span>  </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">lcs</span><span>;</span><span>
</span><span>}</span><span>
</span><span>
</span><span style="color:#65737e;">// Disclaimer - I modified this code to get a similar</span><span>
</span><span style="color:#65737e;">// result format to the previous functions.</span><span>
</span><span style="color:#b48ead;">function </span><span style="color:#8fa1b3;">findSingleEdit</span><span>(</span><span style="color:#bf616a;">A</span><span>, </span><span style="color:#bf616a;">B</span><span>) {</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">lcs </span><span>= </span><span style="color:#8fa1b3;">longestCommonSubsequence</span><span>(</span><span style="color:#bf616a;">A</span><span>, </span><span style="color:#bf616a;">B</span><span>);</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Find the deletion</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">deletion </span><span>= </span><span style="color:#bf616a;">A</span><span>.</span><span style="color:#8fa1b3;">map</span><span>((</span><span style="color:#bf616a;">value</span><span>, </span><span style="color:#bf616a;">index</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>({ </span><span style="color:#bf616a;">value</span><span>, </span><span style="color:#bf616a;">index </span><span>}))</span><span>
</span><span>    .</span><span style="color:#8fa1b3;">filter</span><span>(</span><span style="color:#bf616a;">x </span><span style="color:#b48ead;">=&gt; </span><span>!</span><span style="color:#bf616a;">lcs</span><span>.</span><span style="color:#8fa1b3;">some</span><span>(</span><span style="color:#bf616a;">l </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">l</span><span>.</span><span style="color:#bf616a;">indexA </span><span>=== </span><span style="color:#bf616a;">x</span><span>.index));</span><span>
</span><span>
</span><span>  </span><span style="color:#65737e;">// Find the insertion</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">insertion </span><span>= </span><span style="color:#bf616a;">B</span><span>.</span><span style="color:#8fa1b3;">map</span><span>((</span><span style="color:#bf616a;">value</span><span>, </span><span style="color:#bf616a;">index</span><span>) </span><span style="color:#b48ead;">=&gt; </span><span>({ </span><span style="color:#bf616a;">value</span><span>, </span><span style="color:#bf616a;">index </span><span>}))</span><span>
</span><span>    .</span><span style="color:#8fa1b3;">filter</span><span>(</span><span style="color:#bf616a;">x </span><span style="color:#b48ead;">=&gt; </span><span>!</span><span style="color:#bf616a;">lcs</span><span>.</span><span style="color:#8fa1b3;">some</span><span>(</span><span style="color:#bf616a;">l </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">l</span><span>.</span><span style="color:#bf616a;">indexB </span><span>=== </span><span style="color:#bf616a;">x</span><span>.index));</span><span>
</span><span>  </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">insertion</span><span>.length === </span><span style="color:#d08770;">0 </span><span>|| </span><span style="color:#bf616a;">deletion</span><span>.length === </span><span style="color:#d08770;">0</span><span>) </span><span style="color:#b48ead;">return</span><span>;</span><span>
</span><span>
</span><span>  </span><span style="color:#b48ead;">const </span><span style="color:#bf616a;">movedElement </span><span>= </span><span style="color:#bf616a;">deletion</span><span>[</span><span style="color:#d08770;">0</span><span>].value;</span><span>
</span><span>
</span><span>  </span><span style="color:#b48ead;">return </span><span>{ </span><span style="color:#bf616a;">movedElement</span><span>, from: </span><span style="color:#bf616a;">deletion</span><span>[</span><span style="color:#d08770;">0</span><span>].index, to: </span><span style="color:#bf616a;">insertion</span><span>[</span><span style="color:#d08770;">0</span><span>].index };</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Something I found interesting here is that my prompt is more broken down into two steps:</p>
<ul>
<li>Use LCS</li>
<li>Tell me the edits</li>
</ul>
<p>In response Copilot gave me two separate functions. This one also seems to be correct.
I wrote some unit tests using a few variations of <code>b</code> and got the results I was looking for.</p>
<h2 id="what-was-i-supposed-to-be-doing-again">What was I supposed to be doing again?</h2>
<p>With a working LCS function in hand I could finally overcome the limited API of Framer and use the more appropriate edit function provided by <code>react-hook-form</code>. I was also able to clean up quite a bit of our own code that was trying to guess at this difference. Less code here also meant removing intermediate state and some <code>useEffect</code> from the component which made the whole thing easier to grok. More importantly to me remaining employed after this much tinkering, this helped with the performance of the drag and drop functionality. Since we had unique <code>key</code> props on the top level components being rendered in the list, the performance improvments likely came as a result of the simplified component code and eliminating so much <code>useState</code> and <code>useEffect</code> which would force renders.</p>
<p>The performance of editing the dynamic form components was addressed primarily with <code>useMemo</code>, <code>useCallback</code> and refactoring components to limit the touch points of <code>useContext</code> so fewer things rendered on each keystroke. That was quite a bit more work than the edit distance stuff, but it also probably isn't very interesting to read about.</p>
<p>In the end this made me miss Elixir which provides two <a href="https://hexdocs.pm/elixir/1.12/String.html#myers_difference/2">edit distance functions</a> for strings in the standard library. It also provides them for the <code>List</code> type so I could have stayed in the standard library and never had to touch any of this. Unfortunately nobody seems interested in paying me to write Elixir or F# code.</p>

    </div>
</article>

        </main>
        
        <footer>
            
            <div class="border"></div>
            <div class="footer">
                <small class="footer-left">
                    Copyright &copy; Michael
                </small>
                <small class="footer-right">
                    Powered by <a href="https://www.getzola.org">Zola</a> | Theme <a href="https://github.com/barlog-m/oceanic-zen">Oceanic Zen</a>
                </small>
            </div>
        
        </footer>
    
        </div>
    </body>
</html>
